## Implements an interface for STM in tm.cpp by using TL2 algorithm
TL2 Algorithm Outline:

2 Transactional Locking II
The TL2 algorithm we describe here is a global version-clock based variant of the transactional locking algorithm of Dice and Shavit (TL) [18]. As we will explain, based on this global versioning approach, and in contrast with prior local versioning approaches, we are able to eliminate several key safety issues afflicting other lock-based STM systems and simplify the process of mechanical code transformation. In addition, the use of global versioning will hopefully improve the performance of read-only transactions.
Our TL2 algorithm is a two-phase locking scheme that employs commit- time lock acquisition mode like the TL algorithm, differing from encounter-time algorithms such as those by Ennals [5] and Saha et al. [11].
For each implemented transactional system (i.e. per application or data struc- ture) we have a shared global version-clock variable. We describe it below using an implementation in which the counter is incremented using an increment-and- fetch implemented with a compare-and-swap (CAS) operation. Alternative im- plementation exist however that offer improved performance. The global version- clock will be read and incremented by each writing transaction and will be read by every read-only transaction.
We associate a special versioned write-lock with every transacted memory location. In its simplest form, the versioned write-lock is a single word spinlock that uses a CAS operation to acquire the lock and a store to release it. Since one only needs a single bit to indicate that the lock is taken, we use the rest of the lock word to hold a version number. This number is advanced by every successful lock-release. Unlike the TL algorithm or Ennals [5] and Saha et al. [11], in TL2 the new value written into each versioned write-lock location will be a property which will provide us with several performance and correctness benefits.
To implement a given data structure we allocate a collection of versioned write-locks. We can use various schemes for associating locks with shared data: per object (PO), where a lock is assigned per shared object, or per stripe (PS), where we allocate a separate large array of locks and memory is striped (parti- tioned) using some hash function to map each transactable location to a stripe. Other mappings between transactional shared variables and locks are possible. The PO scheme requires either manual or compiler-assisted automatic inser- tion of lock fields whereas PS can be used with unmodified data structures. PO might be implemented, for instance, by leveraging the header words of objects in the Java programming language [22, 23]. A single PS stripe-lock array may be shared and used for different TL2 data structures within a single address-space. For instance an application with two distinct TL2 red-black trees and three TL2 hash-tables could use a single PS array for all TL2 locks. As our default mapping we chose an array of 220 entries of 32-bit lock words with the mapping function masking the variable address with “0x3FFFFC” and then adding in the base address of the lock array to derive the lock address.
In the following we describe the PS version of the TL2 algorithm although most of the details carry through verbatim for PO as well. We maintain thread lo- cal read- and write-sets as linked lists. Each read-set entries contains the address of the lock that “covers” the variable being read, and unlike former algorithms, does not need to contain the observed version number of the lock. The write-set entries contain the address of the variable, the value to be written to the vari- able, and the address of its associated lock. In many cases the lock and location address are related and so we need to keep only one of them in the read-set. The write-set is kept in chronological order to avoid write-after-write hazards.
2.1 The Basic TL2 Algorithm
We now describe how TL2 executes a sequential code fragment that was placed within a TL2 transaction. As we explain, TL2 does not require traps or the

insertion of validation tests within user code, and in this mode does not require type-stable garbage collection, working seamlessly with the memory life-cycle of languages like C and C++.
Write Transactions The following sequence of operations is performed by a writing transaction, one that performs writes to the shared memory. We will assume that a transaction is a writing transaction. If it is a read-only transac- tion this can be denoted by the programmer, determined at compile time or heuristically at runtime.
1. Sample global version-clock: Load the current value of the global version clock and store it in a thread local variable called the read-version number (rv). This value is later used for detection of recent changes to data fields by comparing it to the version fields of their versioned write-locks.
2. Run through a speculative execution: Execute the transaction code (load and store instructions are mechanically augmented and replaced so that speculative execution does not change the shared memory’s state, hence the term “speculative”.) Locally maintain a read-set of addresses loaded and a write-set address/value pairs stored. This logging functionality is imple- mented by augmenting loads with instructions that record the read address and replacing stores with code recording the address and value to-be-written. The transactional load first checks (using a Bloom filter [24]) to see if the load address already appears in the write-set. If so, the transactional load returns the last value written to the address. This provides the illusion of processor consistency and avoids read-after-write hazards.
A load instruction sampling the associated lock is inserted before each orig- inal load, which is then followed by post-validation code checking that the location’s versioned write-lock is free and has not changed. Additionally, we make sure that the lock’s version field is ≤ rv and the lock bit is clear. If it is greater than rv it suggests that the memory location has been modified after the current thread performed step 1, and the transaction is aborted.
3. Lock the write-set: Acquire the locks in any convenient order using boun- ded spinning to avoid indefinite deadlock. In case not all of these locks are successfully acquired, the transaction fails.
4. Increment global version-clock: Upon successful completion of lock ac- quisition of all locks in the write-set perform an increment-and-fetch (using a CAS operation for example) of the global version-clock recording the re- turned value in a local write-version number variable wv.
5. Validate the read-set: validate for each location in the read-set that the version number associated with the versioned-write-lock is ≤ rv. We also verify that these memory locations have not been locked by other threads. In case the validation fails, the transaction is aborted. By re-validating the read-set, we guarantee that its memory locations have not been modified while steps 3 and 4 were being executed. In the special case where rv + 1 = wv it is not necessary to validate the read-set, as it is guaranteed that no concurrently executing transaction could have modified it.

6. Commit and release the locks: For each location in the write-set, store to the location the new value from the write-set and release the locations lock by setting the version value to the write-version wv and clearing the write-lock bit (this is done using a simple store).
A few things to note. The write-locks have been held for a brief time when attempting to commit the transaction. This helps improve performance under high contention. The Bloom filter allows us to determine if a value is not in the write-set and need not be searched for by reading the single filter word. Though locks could have been acquired in ascending address order to avoid deadlock, we found that sorting the addresses in the write-set was not worth the effort.
Low-Cost Read-Only Transactions One of the goals of the proposed metho- dology’s design is an efficient execution of read-only transactions, as they domi- nate usage patterns in many applications. To execute a read-only transaction:
1. Sample the global version-clock: Load the current value of the global version-clock and store it in a local variable called read-version (rv).
2. Run through a speculative execution: Execute the transaction code. Each load instruction is post-validated by checking that the location’s ver- sioned write-lock is free and making sure that the lock’s version field is ≤ rv. If it is greater than rv the transaction is aborted, otherwise commits.
As can be seen, the read-only implementation is highly efficient because it does not construct or validate a read-set. Detection of read-only behavior can be done at the level of of each specific transaction site (e.g., method or atomic block). This can be done at compile time or by simply running all methods first as read-only, and upon detecting the first transactional write, abort and set a flag to indicate that this method should henceforth be executed in write mode.
